1,retrofit2的拦截器，有一张图可以很好的说明这个事情，它总共有两个拦截器，一个addInterceptor，一个addNetworkInterceptor，和struts2的拦截器是一样的，都是外层包含内层调用的，就看chain.proceed(chain.request)这个函数，在这个函数前面的，会在前面调用，在这个函数后面的，会先调用完后面的链接链之后才会调用。
2，NetworkInterceptor的监听器只在OKHttp3上起作用，addInterceptor是加在整个retrofit2上的。
3，retrofit2添加的缓存其实会使用从服务器上传来的head里参数来确定是否需要缓存，如果android端需要强制添加缓存的时候，其实就是在数据返回的途中，强制给数据的head中添加需要缓存的标志，这个retrofit的收到这样的返回结果后，就会把它缓存起来，不管服务端是否真的需要添加缓存。
4，Interceptor和NetworkInterceptor还有一个不一样：

5，在android组件或者模块化开发时，两个模块之间的调用其实在gradle中添加上comple project（path：libirary）就可以了，这个还有别于应用组件之间的调用，组件之间的调用应该是非耦合的，偶尔的。基础模块的使命就是被其他的模块调用，没有自己的业务逻辑，可能会互相调用。我们现在的架构是2层架构，是一个app主工程带着无数的基础模块工作，我们直接在主app中将所有的module都comple进去。但是业务一旦庞大起来，我们需要按业务进行组件的分开，这样，我们就有3层架构了，在主app中comple所有的组件，这个时候，组件之间的传递联系将通过系统总线来传递，这样做一个好处就是，我可以任意的去掉组件而不会影响到其他的编译运行，一旦comple，势必会调用里面的方法，而去掉组件之后，这部分调用方法将会无法编译，这才是组件之间需要用组件的真谛。
